#include "orientation.h"

int calc_angles(pvector3df_t acc, pvector3df_t mag, float *tilt, float *azimuth)
{
	vector4df_t state; // Кватернион поворота.
	vector3df_t X  = { 1.0f, 0.0f, 0.0f };
	vector3df_t G_ = { 0.0f, 0.0f, 1.0f };
	vector3df_t M_, X_;
	float a;

	// Если девайс вверх-ногами, изменяем направление поворота,
	// избавляет от вырождений:
	if (acc->z < 0) G_.z = -1.0f;

	//
	// 1. Вычисление наклона:
	//
	
	// Собираем поворот:
	q4f_create_rotate(&state, acc, &G_);
	// Вычисляем:
	transform_g2l(&X_, &state, &X);   // Крутим вектор X (l2g?)
	X = X_;                           //
	if (SQR(X_.x) + SQR(X_.y) < 0.003f)
	{
		// Прибор в вектикальном состоянии! 
		// Чтобы исключить вырождение проекции вектора, 
		// просто выводим угол 90 градусов.
		a = PI/2;
	}
	else
	{
		X_.z = 0.0f;                  // Проецируем вектор на плоскость (ОПЯТЬ ВОЗМОЖНО ВЫРОЖДЕНИЕ!).
		a = v3f_angle(&X, &X_);       // Вычисляем угол между вектором и проекцией.
	}
	a = (X.z > 0.0f) ? a : -a;        // Диапазон углов -90-90.
	a = (acc->z > 0.0f) ? a : -a;     // Учет перевертыша в начале.
	*tilt = (a/PI)*180.0f;            // Переводим в градусы, сохраняем.

	//
	// 2. Вычисление азимута:
	//

	if ((a ==  PI/2) ||
		(a == -PI/2))
	{
		// Вертикальное положение, азимут не может быть вычислен:
		*azimuth = 0.0f;
		return 1;
	}
	// Вычисляем:
	transform_g2l(&M_, &state, mag);  // Производим поворот вектора M по G.
	M_.z = 0.0f;                      // Убираем у магнитного вектора составляющую Z.
	a = v3f_angle(&M_, &X_);          // Вычисляем угол между векторами.
	a = (M_.y > 0.0f) ? (2*PI-a) : a; // Пересчитываем на диапазон 0-360.
	a = (acc->z > 0.0f) ? a : (2*PI-a);// Учет перевернутого случая.
	a = (a/PI) * 180.0f;              // Переводим в градусы
	*azimuth = a;

#if 0
	// неверно
	
	// Собираем поворот:
	q4f_create_rotate(&state, acc, &G_);
	// Вычисляем:
	transform_g2l(&M_, &state, mag);  // Производим поворот вектора M по G.
	M_.z = 0.0f;                      // Убираем у магнитного вектора составляющую Z.
	a = v3f_angle(&M_, &X);           // Вычисляем угол между векторами.
	if (acc->z < 0)
		a = (M_.y > 0.0f) ? (2*PI-a) : a; // Пересчитываем на диапазон 0-360.
	else
		a = (M_.y > 0.0f) ? a : (2*PI-a); // Пересчитываем на диапазон 0-360.
	a = (a/PI) * 180.0f;              // Переводим в градусы
	*azimuth = a;
#endif
	
	return 0;
}
